$(function () {
  // loadCensusTracts()
  // loadMunis()
  loadTestMuni()
  // loadMapc()
});

const tabs = document.querySelectorAll('.tab')
let censusTractData, munisData, exposureData, adaptiveCapacityData, mapcData;

// create an instance of Leaflet map, centered on MAPC region
let map = L.map('map').setView([42.358056, -71.063611], 10);
L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
  attribution: 'Map data &copy; OpenStreetMap contributors'
}).addTo(map);

// const censusTracts = new L.GeoJSON.AJAX('lib/geo/censusTracts');
const loadCensusTracts = () => {
  fetch("../fixtures/census-tracts.json")
    .then(function (response) {
      return response.json();
    })
    .then(function (data) {
      console.log('census_tracts data: ', data)
      L.geoJSON(data).addTo(map)
    })
}

const loadTestMuni = () => {
  fetch("../fixtures/testmuni.json")
    .then(function (response) {
      return response.json();
    })
    .then(function (data) {
      console.log('testmuni data: ', data)
      L.geoJSON(data).addTo(map)
    })
}

// const loadMunis = () => {
//   fetch("../fixtures/ma-munis.json")
//     .then(function (response) {
//       return response.json();
//     })
//     .then(function (data) {
//       console.log('munis data: ', data)
//       L.geoJSON(data).addTo(map)
//     })
// }

// const loadMapc = () => {
//   fetch("../fixtures/mapc.json")
//     .then(function (response) {
//       return response.json();
//     })
//     .then(function (data) {
//       console.log('mapc polygon data: ', data)
//       L.geoJSON(data.features).addTo(map)
//     })
// }

const loadExposure = () => {
  // add Exposure layer
}

const loadSensitivity = () => {
  // add Sensitivity layer
}

const loadAdaptiveCapacity = () => {
  // add Adaptive Capacity layer
}


// receive census tract data; access geo data of each; color the tract according to map legend
// function loadRegion(munis) {
  // munis.forEach((muni) => {
  // draw muni shape using muni geo data


  // if (muni) {
  //   geocoder.geocode({ searchText: marker.address_string }, onResult, function (error) {
  //     console.log("error with geocode request: ", error);
  //   })
  //   function onResult(data) {
  //     if (data && data.Response.View[0]) {
  //       marker.geocode = [data.Response.View[0].Result[0].Location.DisplayPosition.Latitude, data.Response.View[0].Result[0].Location.DisplayPosition.Longitude].toString()

  //       new L.marker(marker.geocode.split(',').map(c => parseFloat(c)), {
  //         icon: icons[marker.vote_preference]
  //       }).addTo(map)
  //     }
  //   }
  // }
  // })
// }

// receive census tract data; access geo data of each; color the tract according to map legend
// function loadTracts(tracts) {
//   tracts.forEach((marker) => {
//     if (marker) {
//       geocoder.geocode({ searchText: marker.address_string }, onResult, function (error) {
//         console.log("error with geocode request: ", error);
//       })
//       function onResult(data) {
//         if (data && data.Response.View[0]) {
//           marker.geocode = [data.Response.View[0].Result[0].Location.DisplayPosition.Latitude, data.Response.View[0].Result[0].Location.DisplayPosition.Longitude].toString()

//           new L.marker(marker.geocode.split(',').map(c => parseFloat(c)), {
//             icon: icons[marker.vote_preference]
//           }).addTo(map)
//         }
//       }
//     }
//   })
// }

// class Tract {
//   constructor(obj) {
//     this.id = obj.id
//     this.geocode = obj.geocode
//   }
// }

// Tract.prototype.TractHTML = function () {
//   // color the tract according to the map legend, using the geocode data
// }
