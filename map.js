// document ready, load listeners
$(function () {
  loadCensusTracts()
  loadMunis()
  listenForTabClicks()
});

const tabs = document.querySelectorAll('.tab')


// const censusTracts = new L.GeoJSON.AJAX('lib/geo/censusTracts');
const loadCensusTracts = () => {
  fetch("../fixtures/censusTracts.json")
    .then(function (response) {
      return response.json();
    })
    .then(function (data) {
      console.log('data: ', data)
    })
}

const loadMunis = () => {
  fetch("../fixtures/ma-munis.json")
    .then(function (response) {
      return response.json();
    })
    .then(function (data) {
      mapMunis(data)
    })
}

const listenForTabClicks = () => {
  tabs.foreach(tab => tab.addEventListener('click', (event) => console.log(event.currentTarget.innerText)))
  //load a map layer and turn off the others, or display a combination of them  ))
}
// baseURL can be switched to local Rails server or Heroku
// const baseURL = 'http://127.0.0.1:3000/api/'
// const baseURL = 'https://Tract-preference-api.herokuapp.com/api/'

// API service www.here.com to geocode street address and vice versa
let platform = new H.service.Platform({
  useCIT: true,
  'app_id': "HCIyXQOhmMjxjUE3NteH",
  'app_code': 'ax8hst6McVJjLFKhWRkz1A',
  useHTTPS: true
});

// create an instance of Leaflet map, centered on MAPC region
let map = L.map('map').setView([42.358056, -71.063611], 10);
L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
  attribution: 'Map data &copy; OpenStreetMap contributors'
}).addTo(map);

function mapMunis(data) {
  data.forEach(L.geoJSON(data).addTo(map))
}


// receive census tract data; access geo data of each; color the tract according to map legend
function loadRegion(munis) {
  // munis.forEach((muni) => {
  // draw muni shape using muni geo data


  // if (muni) {
  //   geocoder.geocode({ searchText: marker.address_string }, onResult, function (error) {
  //     console.log("error with geocode request: ", error);
  //   })
  //   function onResult(data) {
  //     if (data && data.Response.View[0]) {
  //       marker.geocode = [data.Response.View[0].Result[0].Location.DisplayPosition.Latitude, data.Response.View[0].Result[0].Location.DisplayPosition.Longitude].toString()

  //       new L.marker(marker.geocode.split(',').map(c => parseFloat(c)), {
  //         icon: icons[marker.vote_preference]
  //       }).addTo(map)
  //     }
  //   }
  // }
  // })
}

// receive census tract data; access geo data of each; color the tract according to map legend
function loadTracts(tracts) {
  tracts.forEach((marker) => {
    if (marker) {
      geocoder.geocode({ searchText: marker.address_string }, onResult, function (error) {
        console.log("error with geocode request: ", error);
      })
      function onResult(data) {
        if (data && data.Response.View[0]) {
          marker.geocode = [data.Response.View[0].Result[0].Location.DisplayPosition.Latitude, data.Response.View[0].Result[0].Location.DisplayPosition.Longitude].toString()

          new L.marker(marker.geocode.split(',').map(c => parseFloat(c)), {
            icon: icons[marker.vote_preference]
          }).addTo(map)
        }
      }
    }
  })
}

class Tract {
  constructor(obj) {
    this.id = obj.id
    this.geocode = obj.geocode
  }
}

Tract.prototype.TractHTML = function () {
  // color the tract according to the map legend, using the geocode data
}
